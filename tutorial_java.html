<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="description" content="Cloud Framework for fault-tolerant distributed processing with dynamic load balancing">
<meta name="keywords" content="tutorial, java, cloud, private cloud, framework, erlang, fault tolerant, distributed systems, embarrassingly parallel, divide and conquer, cloudi">
<title>CloudI Java Tutorial</title>
<link rel="stylesheet" href="./asciidoctor_default.css">
</head>
<body class="article">
<div id="header">
<h1>CloudI Java Tutorial</h1>
<div class="details">
<span id="revnumber">version 1.5.2,</span>
<span id="revdate">2016-09-01</span>
</div>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#reliable_book_recommendations">Reliable Book Recommendations</a>
<ul class="sectlevel2">
<li><a href="#why_does_java_source_code_need_cloudi_to_be_reliable">Why Does Java Source Code Need CloudI To Be Reliable?</a></li>
<li><a href="#what_do_book_recommendations_look_like_in_cloudi">What Do Book Recommendations Look Like In CloudI?</a>
<ul class="sectlevel3">
<li><a href="#what_is_the_structure_of_the_book_recommendation_service">What Is The Structure Of The Book Recommendation Service?</a></li>
<li><a href="#handling_requests">Handling Requests</a></li>
</ul>
</li>
<li><a href="#how_do_book_recommendations_occur">How Do Book Recommendations Occur?</a>
<ul class="sectlevel3">
<li><a href="#creating_book_recommendations">Creating Book Recommendations</a></li>
<li><a href="#how_is_the_book_recommendation_data_processed">How Is The Book Recommendation Data Processed?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="reliable_book_recommendations">Reliable Book Recommendations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For an example of how CloudI can provide fault-tolerance for CloudI services implemented in Java we will explore how books can receive reliable recommendations.
We will use books data from <a href="http://www.gutenberg.org/">Project Gutenberg</a> and Java source code from the <a href="http://lenskit.org/">Lenskit recommendation toolkit</a> to provide reliable book recommendations.</p>
</div>
<div class="sect2">
<h3 id="why_does_java_source_code_need_cloudi_to_be_reliable">Why Does Java Source Code Need CloudI To Be Reliable?</h3>
<div class="paragraph">
<p>Any actively developed source code may have software errors which cause a system to fail but fault-tolerance makes the failure isolated (both in time and area).
With a software system gradually changing as requirements are added or removed it is important that reliability remains constant, despite developer mistakes.
While Java development relies upon exception handling for any runtime problems the scope of failures that exception handling can resolve is very limited.
If you consider the potential for memory leaks or corruption with Java Native Interface (JNI) usage, threading deadlocks or race conditions and memory exhaustion, it should be easy to understand that failures may occur in many unexpected ways.</p>
</div>
<div class="paragraph">
<p>Limiting the scope of a failure in Java source code requires isolated memory to make sure the failure is isolated.
The Java Virtual Machine (JVM) relies on the use of global state with stop-the-world Garbage Collection to manage its use of memory.
However, the lack of isolation in the JVM requires external management to limit the scope of failures within Java source code.</p>
</div>
<div class="paragraph">
<p>Typically Java source code uses an application server to provide external management as an Operating System (OS) process and CloudI provides application server functionality.
Many Java application servers include Java Message Service (JMS) and various Enterprise Service Bus (ESB) solutions exist for use in Java source code.
CloudI provides its own Enterprise Service Bus specifically for CloudI services so that service messaging and service lifetime can both be managed efficiently while keeping service memory isolated.
The approach in CloudI simplifies development so the focus can remain on business logic while CloudI handles any fault-tolerance or scalability concerns of the source code.</p>
</div>
</div>
<div class="sect2">
<h3 id="what_do_book_recommendations_look_like_in_cloudi">What Do Book Recommendations Look Like In CloudI?</h3>
<div class="paragraph">
<p>The source code used in this tutorial is available at <a href="https://github.com/CloudI/cloudi_tutorial_java#readme" target="_blank">https://github.com/CloudI/cloudi_tutorial_java</a>.
A single Java CloudI service is used to provide a REST API that handles book recommendations with the following Uniform Resource Locator (URL) path suffixes:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">URL Path Suffix</th>
<th class="tableblock halign-left valign-top">HTTP Method</th>
<th class="tableblock halign-left valign-top">CloudI Service Name Pattern Suffix</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">item/refresh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">item/refresh/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">item/list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">item/list/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">language/list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">language/list/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">subject/list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">subject/list/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">recommendation/refresh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">recommendation/refresh/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">recommendation/update</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">recommendation/update/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">recommendation/list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">recommendation/list/post</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">client/get</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The table above shows how the HTTP method becomes a suffix on the URL path to create the CloudI service name pattern suffix (cloudi_service_http_cowboy adds the HTTP method as a suffix in lowercase when sending the HTTP request data as a CloudI service request).
When the CloudI service is configured, a service name pattern prefix is provided to describe the scope of the service.
For the book recommendation Java service, the prefix "/tutorial/java/service/" is used so the full service name pattern for the table&#8217;s first entry becomes "/tutorial/java/service/item/refresh/post".
A CloudI service name pattern suffix is used with a subscribe CloudI API function call to declare a service process will accept service requests with a matching service name.</p>
</div>
<div class="paragraph">
<p>When multiple processes and multiple threads are specified in the configuration of a CloudI service (with a count greater than 1), the same service will naturally call the subscribe CloudI API function more than once to declare multiple subscriptions.
A CloudI service that sends a service request with a matching service name will have the service request delivered to a service thread that is randomly selected from the available subscriptions.
Using random selection of a destination that matches the service name keeps the fault-tolerance of the receiving service constant (i.e., with the same probability of a failure for each receive).</p>
</div>
<div class="paragraph">
<p>All CloudI service request receives depend on a previous call to the subscribe CloudI API function.
However, both the send_sync and send_async CloudI API functions send a service request to a single destination.
To send a service request to all destinations that match a service name requires using the function mcast_async in the CloudI API, which is similar to publish functionality in other messaging systems.</p>
</div>
<div class="sect3">
<h4 id="what_is_the_structure_of_the_book_recommendation_service">What Is The Structure Of The Book Recommendation Service?</h4>
<div class="paragraph">
<p>All services are structured for a 3 part sequence: initialization, handling-requests, and termination.
During CloudI service initialization, data structures are initialized to confirm that the service is ready for a runtime that may last indefinitely (making the  initialization stage the most critical stage for a service&#8217;s reliability).
Inside the service initialization the subscribe CloudI API function is typically called so that incoming service requests are handled after initialization is done.
The book recommendation service initialization is shown below (from <a href="https://github.com/CloudI/cloudi_tutorial_java/blob/master/src/main/java/org/cloudi/examples/tutorial/Service.java#L90-L140" target="_blank">Service.java:90-140</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    public void run()
    {
        try
        {
            Main.info(this, "initialization begin");
            // initialization timeout is enforced
            // based on the service configuration value
            if (Service.lenskit() == null)
            {
                throw new RuntimeException("Lenskit initialization failed");
            }

            // subscribe to different CloudI service name patterns
            if (this.api.process_index() == 0 &amp;&amp;
                this.thread_index == 0)
            {
                // only a single thread of a single OS process
                // should handle items refresh due to filesystem usage
                this.api.subscribe("item/refresh/post",
                                   this, "itemRefresh");
            }
            this.api.subscribe("item/list/post",
                               this, "itemList");
            this.api.subscribe("language/list/post",
                               this, "languageList");
            this.api.subscribe("subject/list/post",
                               this, "subjectList");
            if (this.thread_index == 0)
            {
                // only a single thread in any OS process
                // should handle recommendation refresh due to global data
                this.api.subscribe("recommendation/refresh/post",
                                   this, "recommendationRefresh");
            }
            this.api.subscribe("recommendation/update/post",
                               this, "recommendationUpdate");
            this.api.subscribe("recommendation/list/post",
                               this, "recommendationList");
            if (this.thread_index != 0)
            {
                // persistent connections that lack a standard routing
                // identifier in their protocol (like websockets)
                // use the same service name for all requests
                // which must be routed based on the content of the request
                // (do not utilize thread 0, so that it can be used
                //  as a forward destination, for requests that require it)
                this.api.subscribe("client/get",
                                   this, "client");
            }

            Main.info(this, "initialization end");
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The initialization sequence above shows that Lenskit is initialized first.
Afterwards, all the subscribe CloudI API function calls occur with a few choosing specific threads for execution.
You will notice that the Service object instant pointer <code>this</code> is provided with a string function name in the subscribe function call so that the service request will be handled in a specific function (Java 8 allows a single method reference to be used instead of these two separate parameters).
The "itemRefresh" service request can take a few minutes and creates filesystem data, so this request is only handled by a single thread within a single process (to make sure the execution is never parallel with other service threads).
The "recommendationRefresh" service request may take a minute or two with many recommendations but is updating global data in a single process, so it gets its own thread.
The "client" service request is used by the WebSocket interface to handle any of the service&#8217;s functionality with a single WebSocket connection and its functionality will never block the occurrence of the "recommendationRefresh" service request.</p>
</div>
<div class="paragraph">
<p>All of the subscriptions that have been discussed are simply for CloudI service requests that define the interface of a REST API.
For the REST API to be used by HTTP requests, a HTTP server that creates CloudI service requests needs to be used.
CloudI includes two CloudI services that are HTTP Servers: cloudi_service_http_cowboy and cloudi_service_http_elli.
The book recommendation service will use cloudi_service_http_cowboy for handling both basic HTTP requests and WebSocket requests.</p>
</div>
<div class="paragraph">
<p>The initialization sequence ends when the poll CloudI API function is called to begin handling requests.</p>
</div>
</div>
<div class="sect3">
<h4 id="handling_requests">Handling Requests</h4>
<div class="paragraph">
<p>CloudI service requests are processed in-memory and not persisted to disk because service requests are transient transactional data which may or may not represent a failure (only the sender really knows if it is a failure based on the response).
When a CloudI service request receives a response the transaction is complete.
To identify the transaction during its lifetime a globally unique Transaction Identifier (often named <code>trans_id</code> or <code>TransId</code> in the source code) is used within both the request and the response.</p>
</div>
<div class="paragraph">
<p>All CloudI service requests are able to receive a response.
The CloudI service that handles the request can make the request asynchronous by providing a "null response" (a response that has the response data and response_info data set to a binary of size 0) due to the control of the service request passing to the receiver when the service request is handled.
That means that the send_async CloudI API function call is an asynchronous send due to not waiting for a response to occur, though a response may be sent in the future if the receiving service decides to send a response.</p>
</div>
<div class="paragraph">
<p>An example of a service request handling function is below (using the "itemRefresh" function from <a href="https://github.com/CloudI/cloudi_tutorial_java/blob/master/src/main/java/org/cloudi/examples/tutorial/Service.java#L163-L209" target="_blank">Service.java:163-209</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    public Object itemRefresh(Integer command, String name,
                              String pattern, byte[] request_info,
                              byte[] request, Integer timeout,
                              Byte priority, byte[] trans_id,
                              OtpErlangPid pid)
    {
        // refresh all item data asynchronously
        final JSONItemRefreshRequest request_json =
            JSONItemRefreshRequest.fromString(new String(request));
        if (request_json == null)
        {
            return JSONItemRefreshResponse
                .failure("json")
                .toString().getBytes();
        }
        if (this.item_refresh_pending != null &amp;&amp;
            this.item_refresh_pending.isDone() == false)
        {
            return JSONItemRefreshResponse
                .failure("pending")
                .toString().getBytes();
        }
        final String D = System.getProperty("file.separator");
        final String executable_path = System.getProperty("user.dir") + D +
                                       "scripts" + D;
        final String executable_download = executable_path +
                                           "gutenberg_refresh_download";
        final String executable_cleanup = executable_path +
                                          "gutenberg_refresh_cleanup";
        final String directory = System.getProperty("java.io.tmpdir") + D +
                                 (new API.TransId(trans_id)).toString();
        final Connection db = Database.pgsql(Main.arguments());
        if (db == null)
        {
            return JSONItemRefreshResponse
                .failure("db")
                .toString().getBytes();
        }
        // item_refresh takes a long time, so it is done asynchronously
        this.item_refresh_pending = this.item_refresh_executor.submit(
            new GutenbergRefresh(this.idle,
                                 db,
                                 executable_download,
                                 executable_cleanup,
                                 directory));
        return JSONItemRefreshResponse.success().toString().getBytes();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The contents of the service request is contained within the 9 function parameters to keep service request handling consistent with the avoidance of side-effects present in functional programming.
So, while it may seem a bit scary to have 9 function parameters you normally only need to focus on the <code>request</code> parameter which contains the request body.
The return value of the function provides the response body for the response to the service request.
HTTP requests do provide HTTP headers which is request meta-data and all request meta-data is put into the <code>request_info</code> parameter.</p>
</div>
<div class="paragraph">
<p>An important fault-tolerance constraint is the timeout on a service request (i.e., the <code>timeout</code> parameter) since it determines how long the service request is valid.
Every CloudI service request contains a specific timeout value in milliseconds which is decremented when the service request encounters any delay (e.g., due to queuing, handling execution, or forwarding).
The <code>priority</code> parameter controls the priority when a service request is queued and a service request is only queued while the service thread is busy with a separate service request.
The <code>command</code>, <code>name</code>, and <code>pattern</code> parameters show how the service request got here by containing whether the send is asynchronous or synchronous, the service name, and the service name pattern, respectively.
The <code>pid</code> contains the source of the service request as it is represented within the CloudI source code (it is the response destination).</p>
</div>
<div class="paragraph">
<p>While many of the parameters in a service request are just book-keeping for tracking the transaction, the service request can be forwarded through any number of service request handlers before a response is provided.
We can see in the source code example above that a JSON response is always returned as a byte array since the response data is always passed as binary data.
If it was necessary to add HTTP response headers in the response, they would be added to <code>response_info</code> data with the function returning a 2 element array that contains both the <code>response_info</code> meta-data and the <code>response</code> body, respectively.
However, nothing in CloudI enforces the format of the transaction contents (the <code>request_info</code> meta-data input, the <code>request</code> body input, the <code>response_info</code> meta-data output, and the <code>response</code> body output) to keep services loosely coupled.
By not enforcing the data format used in the transaction, CloudI remains protocol agnostic and allows services to fail naturally when they are unable to handle a format.
This approach keeps service development flexible so services can independently change at their own pace.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how_do_book_recommendations_occur">How Do Book Recommendations Occur?</h3>
<div class="paragraph">
<p>To understand how book recommendations occur within the example source code, lets first get the source code running.</p>
</div>
<div class="sect3">
<h4 id="creating_book_recommendations">Creating Book Recommendations</h4>
<div class="paragraph">
<p>Make sure you have Git, curl, Maven with Java 7 (or higher) and PostgreSQL running (&gt;= 9.3).</p>
</div>
<div class="paragraph">
<p>Get a copy of the Java tutorial repository and open a shell in the repository directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">git clone https://github.com/CloudI/cloudi_tutorial_java.git
cd cloudi_tutorial_java</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create the CloudI service configuration for the services used in this tutorial use the following commands in your shell (with the repository directory as the current working directory):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">export JAVA=`which java`
export PWD=`pwd`
export USER=`whoami`
cat &lt;&lt; EOF &gt; website.conf
[[{prefix, "/"},
  {module, cloudi_service_filesystem},
  {args,
   [{directory, "$PWD/html/"}]},
  {dest_refresh, none},
  {count_process, 4}],
 [{prefix, "/tutorial/java/"},
  {module, cloudi_service_http_cowboy},
  {args,
   [{port, 8080}, {use_websockets, true}]},
  {timeout_async, 600000},
  {timeout_sync, 600000}]]
EOF
cat &lt;&lt; EOF &gt; tutorial.conf
[[{prefix, "/tutorial/java/service/"},
  {file_path, "$JAVA"},
  {args, "-Dfile.encoding=UTF-8 "
         "-Dorg.slf4j.simpleLogger.defaultLogLevel=warn "
         "-server "
         "-ea:org.cloudi... "
         "-Xms3g -Xmx3g "
         "-jar $PWD/target/cloudi_tutorial_java-1.5.1-SNAPSHOT-jar-with-dependencies.jar "
         "-pgsql_hostname localhost "
         "-pgsql_port 5432 "
         "-pgsql_database cloudi_tutorial_java "
         "-pgsql_username cloudi_tutorial_java "
         "-pgsql_password cloudi_tutorial_java"},
  {timeout_init, 600000},
  {count_thread, 4},
  {options,
   [{owner, [{user, "$USER"}]},
    {directory, "$PWD"}]}]]
EOF</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration for the Java tutorial CloudI services now is split into two separate files: website.conf (to run initial CloudI services using services that are included in CloudI for hosting the interface and handling HTTP connections) and tutorial.conf (to run the Java tutorial source code for handling book recommendation REST API requests).
The main reason to split the configuration is to make sure all HTTP requests have a 600000 milliseconds (10 minutes) timeout value.
The 10 minute timeout value for a HTTP request allows the Java service for book recommendations to be started dynamically with a 10 minute initialization timeout value for the Lenskit model creation (a 1-2 minute startup time is normal with lots of recommendation data).</p>
</div>
<div class="paragraph">
<p>Make sure you have PostgreSQL setup with a database that matches the Java service configuration arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">psql -U postgres &lt;&lt; EOF
CREATE DATABASE cloudi_tutorial_java;
CREATE USER cloudi_tutorial_java WITH PASSWORD 'cloudi_tutorial_java';
GRANT ALL PRIVILEGES ON DATABASE cloudi_tutorial_java to cloudi_tutorial_java;
EOF</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create the PostgreSQL schema with some test data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">bunzip2 schema.sql.bz2
psql -h localhost cloudi_tutorial_java cloudi_tutorial_java &lt; schema.sql</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the tutorial services can be started by relying on the default CloudI configuration having cloudi_service_http_cowboy running on port 6464 so that CloudI Service API requests can be made dynamically (using cloudi_service_api_requests) to start new service instances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">curl -X POST -d @website.conf http://localhost:6464/cloudi/api/rpc/services_add.erl</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result will be similar to <code>["ServiceId1","ServiceId2"]</code> where <code>ServiceId1</code> is a UUID (Universally Unique Identifier) for the new service instance of cloudi_service_filesystem and <code>ServiceId2</code> is a UUID for the new service instance of cloudi_service_http_cowboy.
The HTTP request above starts the new HTTP server service on port 8080 with the 10 minute timeout value and the web interface files.
Now we can use port 8080 for a CloudI Service API request so the 10 minute timeout value is used when initializing the book recommendation service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">curl -X POST -d @tutorial.conf http://localhost:8080/cloudi/api/rpc/services_add.erl</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result will provide a single service ID for the new Java book recommendation service instance.
With all the tutorial services running successfully we can now look at the book recommendation interface at <a href="http://localhost:8080/tutorial/java/">http://localhost:8080/tutorial/java/</a>.
The interface should look like the screenshot below:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/tutorial_java_interface_01.png" alt="Screenshot 1"></span></p>
</div>
<div class="paragraph">
<p>The green box surrounds the "Items Available" which are Gutenberg Project books included as test data within the <code>schema.sql</code> file.
Set a rating for an item and click the "Rate" button to store the rating.
The button will change to an "Update" button to allow the rating to change in the future.
Set two more ratings in the same way while keeping the user_id value set to <code>1</code>.
Change the user_id value to be <code>2</code>.
Set a rating for one of the items that was rated as user_id <code>1</code>.
The Lenskit recommendation model has not yet been updated based on other user ratings to create suggestions so click the "Update Recommendation Model" button (this update action is typically done weekly or daily with online services that have many users, when Lenskit is used in production).
The interface will update to show a red box that surrounds the "Recommendations Based On Previous Ratings" with expected ratings values that the recommendation model predicted, as shown in the screenshot below (your output will be based on the ratings you set, though it will look similar):</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/tutorial_java_interface_02.png" alt="Screenshot 2"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="how_is_the_book_recommendation_data_processed">How Is The Book Recommendation Data Processed?</h4>
<div class="paragraph">
<p><a href="tutorial.html">Go Back</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>